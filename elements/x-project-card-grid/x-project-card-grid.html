<link rel="import" href="/bower_components/polymer/polymer.html">
<link rel="import" href="../x-project-card/x-project-card.html">

<polymer-element name="x-project-card-grid" attributes="projects sortBy">
  <template>
    <style>
      :host {
        display: block;
      }
      .card-grid {
        display: flex;
        flex-wrap: wrap;
      }

      x-project-card {
        box-sizing: border-box;
        flex-basis: 100%;
        padding: 10px;
        display: block;
      }
      @media only screen and (min-width: 1000px) {
        x-project-card {
          flex-basis: 50%;
        }
      }
    </style>

    <section class="card-grid">
      <template if="{{ projects.length > 0 }}">
        <template repeat="{{ chunk in chunks }}">
          <template repeat="{{ project in chunk }}">
            <x-project-card
              project="{{ project }}"
              favorite?="{{ project.FavoritedByUser }}"></x-project-card>
          </template>
        </template>
      </template>
      <template if="{{ projects.length == 0 }}">
        <content></content>
      </template>
    </section>
  </template>
  <script>
    Polymer('x-project-card-grid', {
      chunkSize: 10,
      created: function() {
        this.projects = [];
        this.sortedProjects = [];
        this.chunks = [];
        this.sortBy = "";
      },
      ready: function() {
        this.currentChunkIndex = 0;
      },
      getPropertyValue: function (object, prop) {
        if (!object.hasOwnProperty(prop)) {
          throw Error("Object does not have property "+prop);
        }

        return object[prop];
      },
      getIteratorValue: function (project, sortBy) {
        var sortKeys = sortBy.split('.'),
          value;

        if (sortKeys.length < 1) {
          throw new Error("No sort keys");
        } else if (sortKeys.length > 3) {
          throw new Error("Too many sort keys");
        }

        // Initially set value as the first key's value
        value = this.getPropertyValue(project, sortKeys[0]);
        // We may need to go deeper.
        for (var i = 1; i < sortKeys.length; i++) {
          value = this.getPropertyValue(value, sortKeys[i]);
        }

        // When value is a string, return it lowercased for proper
        // alphabetical ordering.
        return typeof value === "string" ? value.toLowerCase() : value;
      },
      sortByChanged: function() {
        this.projectsChanged();
      },
      projectsChanged: function() {
        var self = this;

        // Reset chunks
        self.currentChunkIndex = 0;
        self.chunks = [];

        // Set up ordering
        if (self.projects.length > 0 && self.sortBy) {
          var sortBy = self.sortBy,
            reversed = false;

          // sortBy values starting with dash (minus) will cause
          // the list to be reversed
          if (sortBy.indexOf('-') === 0) {
            reversed = true;
            sortBy = sortBy.substring(1);
          }
          try {
            self.sortedProjects = _.sortBy(self.projects, function (project) {
              // null values are no good for Array.prototype.sort()
              if (self.getIteratorValue(project, sortBy) === null) {
                return undefined;
              }
              return self.getIteratorValue(project, sortBy);
            });
          } catch(err) {
            console.log("Something went wrong while sorting. Your localstorage might contain outdated values, clearing.", err);
            self.sortBy = "";
          }

          if (reversed) {
            self.sortedProjects.reverse();
          }
        } else {
          self.sortedProjects = self.projects;
        }

        var array = [];
        for (
          var i = 0;
          i < Math.ceil(self.sortedProjects.length / (1.0 * self.chunkSize));
          i++) {
          array[i] = [];
        };

        self.chunks = array;

        if (self.chunks.length > 0) {
          setTimeout(function() { return self.nextChunk(); }, 150);
        }
      },
      nextChunk: function() {
        var self = this;

        var offset = self.chunkSize * self.currentChunkIndex;

        if (offset >= self.sortedProjects.length) {
          return true;
        }

        for (var i = 0; i < self.chunkSize; i++) {
          if (!self.sortedProjects[offset+i]) {
            break;
          }
          self.chunks[self.currentChunkIndex].push(self.sortedProjects[offset+i]);
        };

        self.currentChunkIndex++;


        setTimeout(function() { return self.nextChunk(); }, 10);
      }
    });
  </script>
</polymer-element>
